#include "lqr.h"
#include "math.h"

/** LQR **/
// 初始化K矩阵
float wheel_K_L[6] = {0, 0, 0, 0, 0, 0};
float joint_K_L[6] = {0, 0, 0, 0, 0, 0};

float wheel_K_R[6] = {0, 0, 0, 0, 0, 0};
float joint_K_R[6] = {0, 0, 0, 0, 0, 0};

// K拟合系数矩阵
float wheel_fitting_factor[6][4] = {
        {-72.041256f,122.292221f,-92.898017f,-0.548635f},
        {-6.337996f,6.988857f,-6.769428f,-0.550505f},

        {-1.751049f,1.211497f,0.010575f,-1.003343f},
        {-2.457993f,1.128865f,0.533932f,-2.304445f},

        {-50.081056f,108.195649f,-87.619105f,26.400007f},
        {-3.759606f,9.003515f,-7.589034f,3.222746f}
};float joint_fitting_factor[6][4] = {
        {406.018760f,-446.433824f,192.874572f,3.649236f},
        {5.751794f,-2.110141f,-5.098812f,1.971446f},

        {0.775476f,3.124691f,-3.518965f,0.062046f},
        {-2.576179f,11.081709f,-9.322273f,0.222554f},

        {399.526559f,-476.267074f,224.798776f,21.741111f},
        {34.618110f,-42.719246f,20.694005f,2.323004f}
};

/** 拟合K **/
void chassis_K_matrix_fitting(float L0, float K[6], const float KL[6][4]) {
    for (int i = 0; i < 6; i++) {
        K[i] = KL[i][0] * powf(L0, 3) + KL[i][1] * powf(L0, 2) + KL[i][2] * powf(L0, 1) + KL[i][3] * powf(L0, 0);
    }
}
